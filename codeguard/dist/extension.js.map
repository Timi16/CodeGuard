{"version":3,"file":"extension.js","mappings":"uuBAGA,iBAAOA,eAA8BC,GACjC,MACMC,EAA8B,GAE9BC,SAHgB,IAAAC,iBAAgBH,IAGhBI,MAAM,MACtBC,QAAiB,IAAAC,qBAGvB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAMM,OAAQD,IAAK,CACnC,MAAME,EAAOP,EAAMK,GACnB,IAAK,MAAMG,KAAWL,EAAU,CAC5B,IAAIM,EACJ,KAAgD,QAAxCA,EAAQD,EAAQA,QAAQE,KAAKH,KAAiB,CAClD,MAAMI,EAAa,IAAIC,EAAOC,WAC1B,IAAID,EAAOE,MAAMT,EAAGI,EAAMM,MAAOV,EAAGI,EAAMM,MAAQN,EAAM,GAAGH,QAC3D,8BAA8BG,EAAM,KACpCG,EAAOI,mBAAmBC,SAE9BlB,EAAOmB,KAAKP,EAChB,CACJ,CACJ,CAG6BC,EAAOO,UAAUC,2BAA2B,kBACpDC,IAAIvB,EAAKC,GAG1BA,EAAOO,OAAS,EAChBM,EAAOU,OAAOC,uBAAuB,kCAAkCxB,EAAOO,wBAE9EM,EAAOU,OAAOC,uBAAuB,8BAE7C,EApCA,kBACA,Q,+sBCGA,oBAAyBC,GACrBC,QAAQC,IAAI,8DAGZ,MAAMC,EAAiBf,EAAOgB,SAASC,gBAAgB,4BAA4BhC,UAC/E,MAAMiC,EAASlB,EAAOU,OAAOS,iBAC7B,GAAID,EACA,UACU,IAAAE,gBAAeF,EAAOG,SAASnC,IACzC,CAAE,MAAOoC,GACLtB,EAAOU,OAAOa,iBAAiB,8BAAiCD,EAAgBE,QACpF,MAEAxB,EAAOU,OAAOC,uBAAuB,6BACzC,IAIEc,EAAoBzB,EAAOgB,SAASC,gBAAgB,wBAAwB,KAC9EjB,EAAOU,OAAOC,uBAAuB,8BAA8B,IAIvEC,EAAQc,cAAcpB,KAAKS,GAC3BH,EAAQc,cAAcpB,KAAKmB,EAC/B,EAGA,wBAA8B,EAhC9B,kBACA,Q,+sBCUA,kBAAOxC,eAA+BC,GAClC,MAAMyC,EAAWzC,EAAI0C,OACrB,OAAO,IAAIC,SAAQ,CAACC,EAASC,KACzBC,EAAGC,SAASN,EAAU,QAAQ,CAACO,EAAKC,KAC5BD,EACAH,EAAOG,GAEPJ,EAAQK,EACZ,GACF,GAEV,EAGA,oBAAOlD,iBAEH,MAAO,CACH,CAAEmD,KAAM,UAAWxC,QAAS,6BAC5B,CAAEwC,KAAM,aAAcxC,QAAS,gCAC/B,CAAEwC,KAAM,WAAYxC,QAAS,8BAC7B,CAAEwC,KAAM,QAASxC,QAAS,2BAGlC,EAlCA,iB,UCAAyC,EAAOC,QAAUC,QAAQ,S,UCAzBF,EAAOC,QAAUC,QAAQ,K,GCCrBC,EAA2B,CAAC,ECE5BC,EDCJ,SAASC,EAAoBC,GAE5B,IAAIC,EAAeJ,EAAyBG,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaN,QAGrB,IAAID,EAASG,EAAyBG,GAAY,CAGjDL,QAAS,CAAC,GAOX,OAHAQ,EAAoBH,GAAUI,KAAKV,EAAOC,QAASD,EAAQA,EAAOC,QAASI,GAGpEL,EAAOC,OACf,CCnB0BI,CAAoB,K","sources":["webpack://codeguard/./src/analyzers/secretAnalyzer.ts","webpack://codeguard/./src/extension.ts","webpack://codeguard/./src/utils/securityUtils.ts","webpack://codeguard/external commonjs \"vscode\"","webpack://codeguard/external node-commonjs \"fs\"","webpack://codeguard/webpack/bootstrap","webpack://codeguard/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport { getFileContents, getSecretPatterns } from '../utils/securityUtils';\n\nexport async function analyzeSecrets(uri: vscode.Uri) {\n    const content = await getFileContents(uri);\n    const issues: vscode.Diagnostic[] = [];\n\n    const lines = content.split('\\n');\n    const patterns = await getSecretPatterns();\n\n    // Analyze each line for secrets\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        for (const pattern of patterns) {\n            let match;\n            while ((match = pattern.pattern.exec(line)) !== null) {\n                const diagnostic = new vscode.Diagnostic(\n                    new vscode.Range(i, match.index, i, match.index + match[0].length),\n                    `Misplaced secret detected: ${match[0]}`,\n                    vscode.DiagnosticSeverity.Warning\n                );\n                issues.push(diagnostic);\n            }\n        }\n    }\n\n    // Create a diagnostic collection\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection('secretAnalyzer');\n    diagnosticCollection.set(uri, issues);\n\n    // Show a summary message\n    if (issues.length > 0) {\n        vscode.window.showInformationMessage(`Secret analysis completed with ${issues.length} issues found.`);\n    } else {\n        vscode.window.showInformationMessage('No misplaced secrets found.');\n    }\n}\n","import * as vscode from 'vscode';\nimport { analyzeSecrets } from './analyzers/secretAnalyzer';\n\n// This method is called when your extension is activated\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('Congratulations, your extension \"codeguard\" is now active!');\n\n    // Register the \"Analyze Code for Secrets\" command\n    const analyzeCommand = vscode.commands.registerCommand('codeguard.analyzeSecrets', async () => {\n        const editor = vscode.window.activeTextEditor;\n        if (editor) {\n            try {\n                await analyzeSecrets(editor.document.uri);\n            } catch (error) {\n                vscode.window.showErrorMessage('Failed to analyze secrets: ' + (error as Error).message);\n            }\n        } else {\n            vscode.window.showInformationMessage('No active editor detected.');\n        }\n    });\n\n    // Register the \"Hello World\" command\n    const helloWorldCommand = vscode.commands.registerCommand('codeguard.helloWorld', () => {\n        vscode.window.showInformationMessage('Hello World from CodeGuard!');\n    });\n\n    // Add commands to the context subscriptions\n    context.subscriptions.push(analyzeCommand);\n    context.subscriptions.push(helloWorldCommand);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\n\n// Define a type for secret detection patterns\nexport type SecretPattern = {\n    name: string;\n    pattern: RegExp;\n};\n\n// Get the file contents as a string\nexport async function getFileContents(uri: vscode.Uri): Promise<string> {\n    const filePath = uri.fsPath;\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Get the patterns for detecting secrets\nexport async function getSecretPatterns(): Promise<SecretPattern[]> {\n    // Return hardcoded patterns\n    return [\n        { name: 'API Key', pattern: /API_KEY\\s*=\\s*['\"].+['\"]/g },\n        { name: 'Secret Key', pattern: /SECRET_KEY\\s*=\\s*['\"].+['\"]/g },\n        { name: 'Password', pattern: /password\\s*=\\s*['\"].+['\"]/g },\n        { name: 'Token', pattern: /token\\s*=\\s*['\"].+['\"]/g },\n        // Add more patterns as needed\n    ];\n}\n","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["async","uri","issues","lines","getFileContents","split","patterns","getSecretPatterns","i","length","line","pattern","match","exec","diagnostic","vscode","Diagnostic","Range","index","DiagnosticSeverity","Warning","push","languages","createDiagnosticCollection","set","window","showInformationMessage","context","console","log","analyzeCommand","commands","registerCommand","editor","activeTextEditor","analyzeSecrets","document","error","showErrorMessage","message","helloWorldCommand","subscriptions","filePath","fsPath","Promise","resolve","reject","fs","readFile","err","data","name","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}