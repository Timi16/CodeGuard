{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://codeguard/./src/analyzers/injectionAnalyzer.ts","webpack://codeguard/./src/analyzers/secretAnalyzer.ts","webpack://codeguard/./src/analyzers/xssAnalyzer.ts","webpack://codeguard/./src/extension.ts","webpack://codeguard/./src/utils/securityUtils.ts","webpack://codeguard/external commonjs \"vscode\"","webpack://codeguard/external node-commonjs \"fs\"","webpack://codeguard/webpack/bootstrap","webpack://codeguard/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\nimport { getFileContents } from '../utils/securityUtils';\n\nexport async function analyzeAdvancedSQLInjection(uri: vscode.Uri) {\n    const content = await getFileContents(uri);\n    const issues: vscode.Diagnostic[] = [];\n\n    // Patterns to detect potentially unsafe SQL query constructions\n    const sqlInjectionPatterns = [\n        /SELECT\\s+.*\\s+FROM\\s+.*\\s+WHERE\\s+.*=.*\\s+('|\").*\\1\\s*;/gi,\n        /INSERT\\s+INTO\\s+.*\\s+VALUES\\s+\\(.*\\)\\s*;/gi,\n        /UPDATE\\s+.*\\s+SET\\s+.*=.*\\s+('|\").*\\1\\s*WHERE\\s+.*=.*\\s*;/gi,\n        /DELETE\\s+FROM\\s+.*\\s+WHERE\\s+.*=.*\\s+('|\").*\\1\\s*;/gi\n    ];\n\n    const lines = content.split('\\n');\n\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n\n        for (const pattern of sqlInjectionPatterns) {\n            let match;\n            while ((match = pattern.exec(line)) !== null) {\n                const diagnostic = new vscode.Diagnostic(\n                    new vscode.Range(i, match.index, i, match.index + match[0].length),\n                    `Potential SQL injection vulnerability: ${match[0]}`,\n                    vscode.DiagnosticSeverity.Warning\n                );\n                issues.push(diagnostic);\n            }\n        }\n\n        // Check if the query is parameterized (absence of hard-coded input in queries)\n        if (/\\${.*?}/.test(line)) {\n            const diagnostic = new vscode.Diagnostic(\n                new vscode.Range(i, 0, i, line.length),\n                `Potentially unsafe dynamic SQL query detected: ${line.trim()}`,\n                vscode.DiagnosticSeverity.Warning\n            );\n            issues.push(diagnostic);\n        }\n    }\n\n    // Create a diagnostic collection\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection('advancedSQLInjectionAnalyzer');\n    diagnosticCollection.set(uri, issues);\n\n    // Show a summary message\n    if (issues.length > 0) {\n        vscode.window.showInformationMessage(`Advanced SQL Injection analysis completed with ${issues.length} issues found.`);\n    } else {\n        vscode.window.showInformationMessage('No advanced SQL Injection vulnerabilities found.');\n    }\n}\n","import * as vscode from 'vscode';\nimport { getFileContents, getSecretPatterns } from '../utils/securityUtils';\n\nexport async function analyzeSecrets(uri: vscode.Uri) {\n    const content = await getFileContents(uri);\n    const issues: vscode.Diagnostic[] = [];\n\n    const lines = content.split('\\n');\n    const patterns = await getSecretPatterns();\n\n    // Analyze each line for secrets\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        for (const pattern of patterns) {\n            let match;\n            while ((match = pattern.pattern.exec(line)) !== null) {\n                const diagnostic = new vscode.Diagnostic(\n                    new vscode.Range(i, match.index, i, match.index + match[0].length),\n                    `Misplaced secret detected: ${match[0]}`,\n                    vscode.DiagnosticSeverity.Warning\n                );\n                issues.push(diagnostic);\n            }\n        }\n    }\n\n    // Create a diagnostic collection\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection('secretAnalyzer');\n    diagnosticCollection.set(uri, issues);\n\n    // Show a summary message\n    if (issues.length > 0) {\n        vscode.window.showInformationMessage(`Secret analysis completed with ${issues.length} issues found.`);\n    } else {\n        vscode.window.showInformationMessage('No misplaced secrets found.');\n    }\n}\n","import * as vscode from 'vscode';\nimport { getFileContents } from '../utils/securityUtils';\n\nexport async function analyzeAdvancedXSS(uri: vscode.Uri) {\n    const content = await getFileContents(uri);\n    const issues: vscode.Diagnostic[] = [];\n\n    // Context-sensitive patterns for XSS detection\n    const xssPatterns = [\n        { context: 'HTML', pattern: /<script[\\s\\S]*?>[\\s\\S]*?<\\/script>/gi },\n        { context: 'HTML', pattern: /<[^>]+on\\w+\\s*=\\s*['\"].*['\"]/gi },\n        { context: 'JavaScript', pattern: /document\\.write\\(/gi },\n        { context: 'JavaScript', pattern: /eval\\(/gi },\n        { context: 'JavaScript', pattern: /innerHTML\\s*=\\s*['\"].*['\"]/gi },\n        { context: 'URL', pattern: /href\\s*=\\s*['\"]javascript:.*['\"]/gi }\n    ];\n\n    const lines = content.split('\\n');\n\n    // Iterate through lines and patterns\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n\n        for (const { context, pattern } of xssPatterns) {\n            let match;\n            while ((match = pattern.exec(line)) !== null) {\n                const diagnostic = new vscode.Diagnostic(\n                    new vscode.Range(i, match.index, i, match.index + match[0].length),\n                    `Potential XSS vulnerability in ${context} context: ${match[0]}`,\n                    vscode.DiagnosticSeverity.Warning\n                );\n                issues.push(diagnostic);\n            }\n        }\n\n        // Check if user input is being directly inserted into HTML/JavaScript without sanitization\n        if (/(\\${.*?})|(\\+\\s*['\"].*['\"])/.test(line)) {\n            const diagnostic = new vscode.Diagnostic(\n                new vscode.Range(i, 0, i, line.length),\n                `Potential unsafe user input usage detected: ${line.trim()}`,\n                vscode.DiagnosticSeverity.Warning\n            );\n            issues.push(diagnostic);\n        }\n    }\n\n    // Create a diagnostic collection\n    const diagnosticCollection = vscode.languages.createDiagnosticCollection('advancedXSSAnalyzer');\n    diagnosticCollection.set(uri, issues);\n\n    // Show a summary message\n    if (issues.length > 0) {\n        vscode.window.showInformationMessage(`Advanced XSS analysis completed with ${issues.length} issues found.`);\n    } else {\n        vscode.window.showInformationMessage('No advanced XSS vulnerabilities found.');\n    }\n}\n","import * as vscode from 'vscode';\nimport { analyzeSecrets } from './analyzers/secretAnalyzer';\nimport { analyzeAdvancedXSS } from './analyzers/xssAnalyzer';\nimport { analyzeAdvancedSQLInjection } from './analyzers/injectionAnalyzer';\n\nexport function activate(context: vscode.ExtensionContext) {\n    console.log('Congratulations, your extension \"codeguard\" is now active!');\n\n    const analyzeSecretsCommand = vscode.commands.registerCommand('codeguard.analyzeSecrets', async () => {\n        const editor = vscode.window.activeTextEditor;\n        if (editor) {\n            try {\n                await analyzeSecrets(editor.document.uri);\n            } catch (error) {\n                vscode.window.showErrorMessage('Failed to analyze secrets: ' + (error as Error).message);\n            }\n        } else {\n            vscode.window.showInformationMessage('No active editor detected.');\n        }\n    });\n\n    const analyzeXSSCommand = vscode.commands.registerCommand('codeguard.analyzeAdvancedXSS', async () => {\n        const editor = vscode.window.activeTextEditor;\n        if (editor) {\n            try {\n                await analyzeAdvancedXSS(editor.document.uri);\n            } catch (error) {\n                vscode.window.showErrorMessage('Failed to analyze XSS: ' + (error as Error).message);\n            }\n        } else {\n            vscode.window.showInformationMessage('No active editor detected.');\n        }\n    });\n\n    const analyzeSQLInjectionCommand = vscode.commands.registerCommand('codeguard.analyzeAdvancedSQLInjection', async () => {\n        const editor = vscode.window.activeTextEditor;\n        if (editor) {\n            try {\n                await analyzeAdvancedSQLInjection(editor.document.uri);\n            } catch (error) {\n                vscode.window.showErrorMessage('Failed to analyze SQL Injection: ' + (error as Error).message);\n            }\n        } else {\n            vscode.window.showInformationMessage('No active editor detected.');\n        }\n    });\n\n    context.subscriptions.push(analyzeSecretsCommand);\n    context.subscriptions.push(analyzeXSSCommand);\n    context.subscriptions.push(analyzeSQLInjectionCommand);\n}\n\nexport function deactivate() {}\n","import * as fs from 'fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\n\n// Define a type for secret detection patterns\nexport type SecretPattern = {\n    name: string;\n    pattern: RegExp;\n};\n\n// Get the file contents as a string\nexport async function getFileContents(uri: vscode.Uri): Promise<string> {\n    const filePath = uri.fsPath;\n    return new Promise((resolve, reject) => {\n        fs.readFile(filePath, 'utf8', (err, data) => {\n            if (err) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\n// Get the patterns for detecting secrets\nexport async function getSecretPatterns(): Promise<SecretPattern[]> {\n    // Return hardcoded patterns\n    return [\n        { name: 'API Key', pattern: /API_KEY\\s*=\\s*['\"].+['\"]/g },\n        { name: 'Secret Key', pattern: /SECRET_KEY\\s*=\\s*['\"].+['\"]/g },\n        { name: 'Password', pattern: /password\\s*=\\s*['\"].+['\"]/g },\n        { name: 'Token', pattern: /token\\s*=\\s*['\"].+['\"]/g },\n        // Add more patterns as needed\n    ];\n}\n","module.exports = require(\"vscode\");","module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["async","uri","issues","sqlInjectionPatterns","lines","getFileContents","split","i","length","line","pattern","match","exec","diagnostic","vscode","Diagnostic","Range","index","DiagnosticSeverity","Warning","push","test","trim","languages","createDiagnosticCollection","set","window","showInformationMessage","patterns","getSecretPatterns","xssPatterns","context","console","log","analyzeSecretsCommand","commands","registerCommand","editor","activeTextEditor","analyzeSecrets","document","error","showErrorMessage","message","analyzeXSSCommand","analyzeAdvancedXSS","analyzeSQLInjectionCommand","analyzeAdvancedSQLInjection","subscriptions","filePath","fsPath","Promise","resolve","reject","fs","readFile","err","data","name","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}